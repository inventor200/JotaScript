function convertData(obj) {
    if (obj === null || obj === undefined) {
        return "";
    }
    if (obj.isProgram) return obj;
    if (obj.isPrintMessage) return obj;
    if (obj.isSequence) return obj;
    const dataType = typeof obj;
    if (dataType === 'number') {
        return obj;
    }
    if (dataType === 'string') {
        return preferNumber(obj);
    }
    if (dataType === 'boolean') {
        return obj === true ? 1 : 0;
    }
    if (Array.isArray(obj)) {
        throw new Error("Use a Sequence instead of an array");
    }
    throw new Error("Unsupported data type: " + dataType);
}

function preferNumber(obj) {
    const dataType = typeof obj;
    if (dataType === 'number') return obj;
    if (dataType === 'string') {
        const parsed = parseInt(obj);
        if (!isNaN(parsed)) return parsed;
    }
    return obj;
}

function forceNumber(obj) {
    const converted = preferNumber(obj);
    if ((typeof converted) != 'number') {
        throw new Error("Not a number: " + obj);
    }
    return converted;
}

function forceBool(obj) {
    const converted = forceNumber(obj);
    if (converted < 0 || converted > 1) {
        throw new Error("Not a boolean: " + obj);
    }
    return converted;
}

function reduceData(context, obj) {
    if (obj && obj.isPrintMessage) {
        return convertData(context.bridge.clearPrintMessage(obj));
    }
    const converted = convertData(obj);
    if (converted.isProgram) {
        return reduceData(context, converted.execute(context));
    }
    return converted;
}

function toArgArray(context, args) {
    let argArr = args;
    if (!Array.isArray(argArr)) {
        argArr = [args];
    }
    const processedArr = [];
    for (let i = 0; i < argArr.length; i++) {
        let item = argArr[i];
        if (!item.isProgram) {
            if ((typeof item) === 'string') {
                item = context.bridge.processSubstitutions(context, item);
            }
        }
        processedArr.push(item);
    }
    return processedArr;
}

function filterExecutable(context, line) {
    // Sometimes a program returns nothing at all,
    // but the system needs to verify that no program
    // layers must be unpacked.
    if (line === undefined) return "";

    if (Array.isArray(line) || (line.isSequence && !line.registeredInField)) {
        throw new Error("Chained inner executions are forbidden.");
    }
    if ((typeof line) === 'string') {
        if (line.startsWith('@')) {
            context.bridge.throwTextCompilationNotImplemented();
        }
    }
    return convertData(line);
}

function unpackSequence(context, seq) {
    let unpacked = [];
    if (!seq.isSequence) {
        if (Array.isArray(seq)) {
            unpacked = seq;
        }
        else {
            unpacked = [seq];
        }
    }
    else {
        for (let i = 0; i < seq.programs.length; i++) {
            unpacked.push(seq.programs[i]);
        }
    }

    return toArgArray(context, unpacked);
}

function enforceDBRef(objOrDBRef) {
    if (objOrDBRef === undefined || objOrDBRef === null) {
        throw new Error("null dbref outlined");
    }
    const type = typeof objOrDBRef;
    if (type === 'number') return objOrDBRef;
    if (type === 'string') return forceNumber(objOrDBRef);
    if (objOrDBRef.isProgram) return objOrDBRef;
    if (objOrDBRef.dbref != undefined) return objOrDBRef.dbref;
    throw new Error("Bad dbref outline type: " + objOrDBRef);
}

// JotaCode enforces all lower-case spelling for programs, flags, and fields.
function enforceFieldNameCapitalization(fieldName) {
    if ((typeof fieldName) === 'string') return fieldName.toLowerCase();
    return fieldName;
}

function compileContent(content) {
    if (content.isProgram || content.isSequence) {
        return content.compile();
    }
    const reduced = convertData(content);
    if ((typeof reduced) === 'string') {
        return '"' + reduced + '"';
    }
    return reduced;
}

class Sequence {
    constructor(programs) {
        this.programs = programs;
        this.isSequence = true;
        this.registeredInField = false;
    }

    compile() {
        let res = '{ ';
        for (let i = 0; i < this.programs.length; i++) {
            res += ',';
            res += compileContent(this.programs[i]);
        }
        return res + ' }';
    }
}

// Multi-instruction access is not possible in JotaCode,
// so what we can do is pre-initialize our arrays beforehand,
// and distribute them as @switch() statements during compile.
//
// This assumes a static array, of course, which is more compact.
// If we want to modify elements on the fly, we will need something
// more complex. However, to not be a menace on the MUD, it's
// best to keep arrays static whenever possible, because the non-
// static injections are a lot more involved.
class JotaArray {
    constructor(parent, arrayName, isStatic, elements) {
        this.arrayName = arrayName;
        this.parent = parent;
        this.isStatic = isStatic;
        this.elements = elements;

        if (!isStatic) {
            for (let i = 0; i < elements.length; i++) {
                parent._setField(
                    this.getIndexFieldName(i), elements[i]
                );
            }
        }
    }

    getIndexFieldName(i) {
        return this.arrayName + 'index' + String(i);
    }

    createGetter(indexProgram) {
        // Dynamic access
        if (indexProgram.isProgram) {
            if (this.isStatic) {
                const switchContents = [];
                switchContents.push(
                    indexProgram
                );
                for (let i = 1; i < this.elements.length; i++) {
                    switchContents.push(i);
                    switchContents.push(this.elements[i]);
                }
                switchContents.push(this.elements[0]);
                
                return this.parent.bridge.a_switch(...switchContents);
            }

            return this.parent.getField(
                this.createIndexedField(indexProgram)
            );
        }

        // Baked access
        //
        // This index will never change, so we can safely just
        // return the value it would access.
        const index = forceNumber(indexProgram);
        if (this.isStatic) {
            return this.elements[index];
        }

        return this.parent.getField(
            this.arrayName + 'index' + index
        );
    }

    createIndexedField(indexProgram) {
        const wrappedIndex = this.parent.bridge.a_execute(indexProgram);
        return this.parent.bridge.a_print(
            this.arrayName + "index",
            wrappedIndex
        );
    }

    createSetter(indexProgram, value) {
        return this.parent.setField(
            this.createIndexedField(indexProgram), value
        );
    }

    // I cannot believe this worked.
    createIterator(iterProgram) {
        if (this.isStatic) {
            // Create a fake field loop, ahahahaha
            const indexSubst = this.arrayName + 'indexiter';
            return this.parent.bridge.a_countloop(
                this.elements.length,
                indexSubst,
                // Okay, something really important...
                // use of @countloop means anything outside of the
                // loop's code only executes ONCE.
                // If you want something to iterate along with the
                // loop, even with substituions, you NEED to put
                // that IN THE LOOP.
                this.parent.bridge.a_let(
                    'f', 'fakearrayiterfield',
                    'v', this.createGetter(
                        this.parent.bridge.a_substitute(
                            '%{' + indexSubst + '}'
                        )
                    ),
                    this.parent.bridge.a_substitute(iterProgram)
                )
            );
        }

        return this.parent.bridge.a_fieldloop(
            this.parent.dbref, this.arrayName + 'index', iterProgram
        );
    }
}

class Program {
    constructor(name, data, ...args) {
        this.isProgram = true;
        this.name = name;
        this.data = data;
        this.args = args;
    }

    execute(context) {
        return this.data(context, ...this.args);
    }

    compile() {
        let res = this.name + '(';
        let argArray = this.args;
        while (Array.isArray(argArray[0])) {
            argArray = argArray[0];
        }
        for (let i = 0; i < argArray.length; i++) {
            if (i > 0) res += ',';
            res += compileContent(argArray[i]);
        }
        return res + ')';
    }
}

class DatabaseObject {
    constructor(bridge, objectType, vocab, dbref) {
        this.bridge = bridge;
        this.objectType = objectType;
        this.vocab = vocab;
        this.dbref = dbref;
        this.flags = [];
        this.fields = [];
        this.arrays = [];
        this.isObject = false;
        this.isPlayer = false;
        this.isRoom = false;
        this.isExit = false;
        this.initializedSafely = false;
        this.arraysAllowed = true;
    }

    /**
     * For internal use only
     * @private
     */
    matchesName(str) {
        const names = this.vocab.split(';');
        for (let i = 0; i < names.length; i++) {
            if (names[i] === str) return true;
        }
        return false;
    }

    /**
     * For internal use only
     * @private
     */
    _getShortName() {
        return this.vocab.split(';')[0];
    }

    /**
     * For internal use only
     * @private
     */
    _setFlag(flagName, state) {
        flagName = enforceFieldNameCapitalization(flagName);
        const index = this.flags.indexOf(flagName);
        if (state) {
            if (index > -1) return;
            this.flags.push(flagName);
        }
        else {
            if (index === -1) return;
            this.flags.splice(index, 1);
        }
    }

    /**
     * For internal use only
     * @private
     */
    _getFlag(flagName) {
        flagName = enforceFieldNameCapitalization(flagName);
        return this.flags.indexOf(flagName) > -1;
    }

    /**
     * For internal use only
     * @private
     */
    _setField(fieldName, value) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        for (let i = 0; i < this.fields.length; i++) {
            const field = this.fields[i];
            if (field.fieldName === fieldName) {
                field.value = value;
                return;
            }
        }
        this.fields.push(new ObjectField(this, fieldName, value));
    }

    /**
     * For internal use only
     * @private
     */
    _getField(fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        for (let i = 0; i < this.fields.length; i++) {
            const field = this.fields[i];
            if (field.fieldName === fieldName) {
                return field.value;
            }
        }

        return "";
    }

    /**
     * For internal use only
     * @private
     */
    _executeField(context, fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        for (let i = 0; i < this.fields.length; i++) {
            const field = this.fields[i];
            if (field.fieldName === fieldName) {
                field.getOutput(context);
                return;
            }
        }
    }

    /**
     * For internal use only
     * @private
     */
    _compileField(fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        for (let i = 0; i < this.fields.length; i++) {
            const field = this.fields[i];
            if (field.fieldName === fieldName) {
                return field.compile();
            }
        }
    }

    /**
     * For internal use only
     * @private
     */
    _getArrayByName(arrayName) {
        arrayName = enforceFieldNameCapitalization(arrayName);
        for (let i = 0; i < this.arrays.length; i++) {
            const arr = this.arrays[i];
            if (arr.arrayName === arrayName) {
                return arr;
            }
        }

        return undefined;
    }

    /**
     * For internal use only
     * @private
     */
    checkInitState(propertyName, settingField=false) {
        if (!this.initializedSafely) {
            console.log(
                'WARNING: ' + this._getShortName() +
                ' has not initialized safely yet! ' +
                'You should use this instead:\n\n    ' +
                'objectName.init().' +
                (settingField ?
                    'setField(' + propertyName + ', startingValue)'
                    :
                    'setFlag(' + propertyName + ', startingState)'
                ) + '\n'
            );
        }
    }

    showMissingArrayError(arrayName) {
        throw new Error(
            "No array '" + arrayName + "' on " +
            this._getShortName()
        );
    }

    // Object-oriented alternatives to program-building:
    registerArray(arrayName) {
        throw new Error(
            "Cannot register array '" + arrayName + "' on " +
            this._getShortName() + " outside of init() pipeline!"
        );
    }

    getArray(arrayName, indexProgram) {
        arrayName = enforceFieldNameCapitalization(arrayName);
        const currentArray = this._getArrayByName(arrayName);
        if (currentArray === undefined) {
            this.showMissingArrayError(arrayName);
        }

        return currentArray.createGetter(indexProgram);
    }

    setArray(arrayName, indexProgram, value) {
        arrayName = enforceFieldNameCapitalization(arrayName);
        const currentArray = this._getArrayByName(arrayName);
        if (currentArray === undefined) {
            this.showMissingArrayError(arrayName);
        }
        if (currentArray.isStatic) {
            throw new Error(
                "Array '" + arrayName + "' on " +
                this._getShortName() + ' is STATIC, and cannot be modified!'
            );
        }
        return currentArray.createSetter(indexProgram, value);
    }

    getFlag(flagName) {
        flagName = enforceFieldNameCapitalization(flagName);
        return this.bridge.a_testflag(this.dbref, flagName);
    }

    setFlag(flagName, state) {
        flagName = enforceFieldNameCapitalization(flagName);
        this.checkInitState(flagName, false);
        if (state === undefined) {
            return this.bridge.a_setflag(this.dbref, flagName);
        }
        return this.bridge.a_setflag(this.dbref,
            (state ? '' : '!') + flagName
        );
    }

    cloneField(fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        return this.bridge.a_getfield(this.dbref, fieldName);
    }

    getField(fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        return this.bridge.a_execute(this.cloneField(fieldName));
    }

    setField(fieldName, value) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        this.checkInitState(fieldName, true);
        return this.bridge.a_setfield(this.dbref, fieldName, value);
    }

    // Shorthand, which allows the dev to think about this in a 
    // functional context, and not in a copy context.
    do(fieldName) {
        return this.getField(fieldName);
    }

    doFor(fieldName, iterations) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        const field = this._getField(fieldName);
        if (field === "") {
            return "";
        }
        return this.bridge.a_countloop(
            iterations, 'repeatforindex',
            this.cloneField(fieldName)
        );
    }

    getLocation() {
        return this.bridge.a_location(this.dbref);
    }

    getRoom() {
        return this.bridge.a_toploc(this.dbref);
    }

    moveTo(destination) {
        return this.bridge.a_move(this.dbref, enforceDBRef(destination));
    }

    getExit(destination) {
        throw new Error("Not a room");
    }

    setDest(destination) {
        throw new Error("Not an exit");
    }

    getName() {
        return this.bridge.a_name(this.dbref);
    }

    getShortName() {
        return this.bridge.a_shortname(this.dbref);
    }

    call(fieldName) {
        fieldName = enforceFieldNameCapitalization(fieldName);
        return this.bridge.a_call(this.dbref, fieldName);
    }

    contentsLoop(substitutionString, iterProgram) {
        return this.bridge.a_contentsloop(this.dbref, substitutionString, iterProgram);
    }

    fieldLoop(fieldPrefix, iterProgram) {
        fieldPrefix = enforceFieldNameCapitalization(fieldPrefix);
        const possibleArray = this._getArrayByName(fieldPrefix);
        if (possibleArray) {
            return possibleArray.createIterator(iterProgram);
        }
        return this.bridge.a_fieldloop(this.dbref, fieldPrefix, iterProgram);
    }

    /**
     * Open an initializer pipeline for this object.
     * We need to do this to make sure we are setting direct
     * initialized values, and not just programs that will do
     * this during execution time.
     */
    init() {
        this.initializedSafely = true;
        return new ObjectInitializer(this);
    }
}

class ObjectInitializer {
    constructor(parent) {
        this.parent = parent;
        this.parent.bridge.localScope = this.parent;
    }

    setField(fieldName, value) {
        this.parent.arraysAllowed = false;
        fieldName = enforceFieldNameCapitalization(fieldName);
        this.parent._setField(fieldName, value);
        return this;
    }

    setFlag(flagName, state) {
        this.parent.arraysAllowed = false;
        flagName = enforceFieldNameCapitalization(flagName);
        if (state === undefined) {
            if (flagName.startsWith('!')) {
                flagName = flagName.substring(1);
                state = false;
            }
            else {
                state = true;
            }
        }
        this.parent._setFlag(flagName, state);
        return this;
    }

    registerArray(arrayName, isStatic, ...elements) {
        if (!this.parent.arraysAllowed) {
            throw new Error(
                "Arrays must be declared FIRST on " +
                this.parent._getShortName()
            );
        }
        arrayName = enforceFieldNameCapitalization(arrayName);
        const currentArray = this.parent._getArrayByName(arrayName);
        const arrElements = [...elements];
        if (currentArray) {
            throw new Error(
                "Array '" + arrayName + "' already registered on " +
                this.parent._getShortName()
            );
        }
        this.parent.arrays.push(new JotaArray(
            this.parent, arrayName, isStatic, arrElements
        ));
        return this;
    }
}

class Ownable extends DatabaseObject {
    constructor(bridge, objectType, vocab, dbref, owner) {
        super(bridge, objectType, vocab, dbref);
        this.owner = owner;
        this.hasPOV = true;
    }

    processMessage(msg) {
        if (!this.hasPOV) return;
        if (msg.isPrintMessage) {
            msg = this.bridge.clearPrintMessage(msg);
        }
        msg = String(convertData(msg)).replace(
            new RegExp('%c', 'gi'), '\n'
        ).replace(
            new RegExp('%%', 'g'), '%'
        );
        console.log('[' + this._getShortName() + ' POV] ' + msg);
    }
}

class Locatable extends Ownable {
    constructor(bridge, objectType, vocab, dbref, owner, location=null) {
        super(bridge, objectType, vocab, dbref, owner);
        this.location = location;
    }
}

class Thing extends Locatable {
    constructor(bridge, vocab, dbref, owner, location=null) {
        super(bridge, 4, vocab, dbref, owner, location);
        this.owner = owner;
        this.isObject = true;
    }
}

class Exit extends Locatable {
    constructor(bridge, vocab, dbref, owner, location=null) {
        super(bridge, 3, vocab, dbref, owner, location);
        this.isExit = true;
    }

    // Object-oriented alternatives to program-building:
    setDest(destination) {
        return this.bridge.a_setdest(this.dbref, enforceDBRef(destination));
    }

    createDest(destination) {
        createField('link', enforceDBRef(destination));
    }
}

class Player extends Locatable {
    constructor(bridge, vocab, dbref, location=null) {
        super(bridge, 2, vocab, dbref, null, location);
        this.owner = this;
        this.isObject = true;
        this.isPlayer = true;
    }
}

class Room extends Ownable {
    constructor(bridge, vocab, owner, dbref) {
        super(bridge, 1, vocab, owner, dbref);
        this.isRoom = true;
    }

    _getShortName() {
        return this.vocab;
    }

    // Object-oriented alternatives to program-building:
    getLocation() {
        return this.dbref;
    }

    getRoom() {
        return this.dbref;
    }

    moveTo(destination) {
        throw new Error("Cannot move room");
    }

    getExitByName(exitName) {
        return this.bridge.a_exit(this.dbref, exitName);
    }
}

class ObjectField {
    constructor(parent, fieldName, startingValue="") {
        this.parent = parent;
        this.fieldName = fieldName;
        this.value = startingValue;
        if (this.value.isSequence) {
            this.value.registeredInField = true;
        }
    }

    getOutput(context) {
        if (this.value === null || this.value === undefined) return;
        if (Array.isArray(this.value)) {
            throw new Error("Use a Sequence instead of an array");
        }
        //console.log(this.value);
        if (this.value.isSequence) {
            for (let i = 0; i < this.value.programs.length; i++) {
                this.getSingleOutput(context, this.value.programs[i]);
            }
        }
        else {
            this.getSingleOutput(context, this.value);
        }
    }

    getSingleOutput(context, jotacode) {
        if (this.value === null || this.value === undefined) return;
        while (jotacode.isProgram) {
            //console.log(jotacode);
            jotacode = (
                context.bridge.a_execute(jotacode)
            ).execute(context);
        }
        if (!jotacode.isProgram) {
            jotacode = convertData(jotacode);
            if (jotacode.isPrintMessage) {
                jotacode = context.bridge.clearPrintMessage(jotacode);
            }
        }
        //console.log(jotacode);
        jotacode = String(jotacode);
        if (jotacode.length === 0) return;
        context.agent.processMessage(jotacode);
    }

    compile() {
        let res = '@field ' + this.parent._getShortName() + '=' +
            this.fieldName + ':';

        if (this.value.isSequence) {
            for (let i = 0; i < this.value.programs.length; i++) {
                if (i > 0) res += ';';
                res += this.compileSingle(this.value.programs[i]);
            }
        }
        else {
            res += this.compileSingle(this.value);
        }

        return res;
    }

    compileSingle(jotacode) {
        if (jotacode.isProgram) {
            return jotacode.compile();
        }
        return String(jotacode);
    }
}

class JotaBridge {
    constructor() {
        this.bridge = this;
        this.registeredObjects = [];
        this.registeredSubstitutions = [];

        this.adminPlayer = new Player(
            this, 'admin player', -2, null
        );
        this.registeredObjects.push(this.adminPlayer);

        this.nowhere = new Room(
            this, 'nowhere', -3, this.adminPlayer
        );
        this.registeredObjects.push(this.nowhere);
        this.adminPlayer.location = this.nowhere;

        this.outputItem = new Thing(
            this, 'output item', -1, this.adminPlayer, this.nowhere
        );
        this.registeredObjects.push(this.outputItem);
        this.outputItem._setField('run', "Hello world!");
        this.printMessages = [];
        this.localScope = null;
    }

    registerThing(vocab, dbref, owner, location=null) {
        const registree = new Thing(this, vocab, dbref, owner, location);
        this.registeredObjects.push(registree);
        return registree;
    }

    registerPlayer(vocab, dbref, location=null) {
        const registree = new Player(this, vocab, dbref, location);
        this.registeredObjects.push(registree);
        return registree;
    }

    registerExit(vocab, dbref, owner, location=null) {
        const registree = new Exit(this, vocab, dbref, owner, location);
        this.registeredObjects.push(registree);
        return registree;
    }

    registerRoom(vocab, dbref, owner) {
        const registree = new Room(this, vocab, dbref, owner);
        this.registeredObjects.push(registree);
        owner.location = registree;
        return registree;
    }

    createSequence(...programs) {
        return new Sequence(programs);
    }

    createContext(
        agent, object,
        exitArg0='', exitArg1='', exitArg2='', exitArg3=''
    ) {
        const certainReference = this;
        return {
            bridge: certainReference,
            agent: agent,
            object: object,
            exitArg0: String(exitArg0),
            exitArg1: String(exitArg1),
            exitArg2: String(exitArg2),
            exitArg3: String(exitArg3),
            exitArg0Lower: String(exitArg0).toLowerCase(),
            exitArg1Lower: String(exitArg1).toLowerCase(),
            exitArg2Lower: String(exitArg2).toLowerCase(),
            exitArg3Lower: String(exitArg3).toLowerCase()
        };
    }

    cloneContent(oldContext) {
        return {
            bridge: oldContext.bridge,
            agent: oldContext.agent,
            object: oldContext.object,
            exitArg0: oldContext.exitArg0,
            exitArg1: oldContext.exitArg1,
            exitArg2: oldContext.exitArg2,
            exitArg3: oldContext.exitArg3,
            exitArg0Lower: oldContext.exitArg0Lower,
            exitArg1Lower: oldContext.exitArg1Lower,
            exitArg2Lower: oldContext.exitArg2Lower,
            exitArg3Lower: oldContext.exitArg3Lower
        };
    }

    createTestContext() {
        return this.createContext(this.adminPlayer, this.outputItem);
    }

    registerPrintMessage(msgContent) {
        const msgObj = {
            isPrintMessage: true,
            content: msgContent
        };
        this.printMessages.push(msgObj);
        return msgObj;
    }

    clearPrintMessage(msgObj) {
        const index = this.printMessages.indexOf(msgObj);
        this.printMessages.splice(index, 1);
        return msgObj.content;
    }

    getRemainingMessages() {
        let res = '';
        for (let i = 0; i < this.printMessages.length; i++) {
            res += this.printMessages[i].content;
        }
        this.printMessages = [];
        return res;
    }

    checkLocalScope() {
        if (!this.localScope) {
            throw new Error("Not in init() mode before calling do(fieldName)!");
        }
    }

    // Shorthand for init() declarations
    ls() {
        this.checkLocalScope();
        return this.localScope;
    }

    // Shorthand for init() declarations
    self() {
        this.checkLocalScope();
        return this.localScope.dbref;
    }

    // Shorthand for init() declarations
    do(fieldName) {
        this.checkLocalScope();
        return this.localScope.do(fieldName);
    }

    // Shorthand for init() declarations
    set(fieldName, value) {
        this.checkLocalScope();
        return this.localScope.setField(fieldName, value);
    }

    // Shorthand for init() declarations
    eval(dstFieldName, srcFieldName) {
        this.checkLocalScope();
        return this.localScope.setField(dstFieldName,
            this.localScope.getField(srcFieldName)
        );
    }

    // Shorthand for init() declarations
    clone(dstFieldName, srcFieldName) {
        this.checkLocalScope();
        return this.localScope.setField(dstFieldName,
            this.localScope.cloneField(srcFieldName)
        );
    }

    // Shorthand for init() declarations
    flag(flagName) {
        this.checkLocalScope();
        return this.localScope.setFlag(flagName, undefined);
    }

    // Shorthand for init() declarations
    read(arrayName, indexProgram) {
        this.checkLocalScope();
        return this.localScope.getArray(arrayName, indexProgram);
    }

    // Shorthand for init() declarations
    write(arrayName, indexProgram, value) {
        this.checkLocalScope();
        return this.localScope.setArray(arrayName, indexProgram, value);
    }

    createSubstitutionPair(key, value) {
        return {
            key: key,
            value: value
        };
    }

    registerSubstitution(subsitutionPair) {
        let key = subsitutionPair.key;
        if (!key.startsWith('%')) {
            key = '%' + key;
        }
        if (key.length > 2) {
            key = '%{' + key.substring(1) + '}';
        }
        subsitutionPair.key = key;
        this.registeredSubstitutions.push(subsitutionPair);
        return subsitutionPair;
    }

    retireSubstitution(subsitutionPair) {
        const index = this.registeredSubstitutions.indexOf(subsitutionPair);
        this.registeredSubstitutions.splice(index, 1);
    }

    processSubstitutions(context, str) {
        if ((typeof str) === 'string') {
            // Handle default substitutions
            str = str.replace(
                new RegExp('%#', 'g'), String(
                    context.agent.dbref
                )
            ).replace(
                new RegExp('%!', 'g'), String(
                    context.object.dbref
                )
            ).replace(
                new RegExp('%s', 'gi'), String(
                    'they (' +
                    context.agent._getShortName() +
                    ')'
                )
            ).replace(
                new RegExp('%n', 'gi'), String(
                    context.agent._getShortName()
                )
            ).replace(
                new RegExp('%p', 'gi'), String(
                    'their (' +
                    context.agent._getShortName() +
                    ')'
                )
            ).replace(
                new RegExp('%a', 'gi'), String(
                    'theirs (' +
                    context.agent._getShortName() +
                    ')'
                )
            ).replace(
                new RegExp('%o', 'gi'), String(
                    'them (' +
                    context.agent._getShortName() +
                    ')'
                )
            ).replace(
                new RegExp('%r', 'gi'), String(
                    'themself (' +
                    context.agent._getShortName() +
                    ')'
                )
            ).replace(
                new RegExp('%l', 'gi'), String(
                    context.agent.location._getShortName()
                )
            ).replace(
                new RegExp('%0', 'g'), String(
                    context.exitArg0Lower
                )
            ).replace(
                new RegExp('%1', 'g'), String(
                    context.exitArg1Lower
                )
            ).replace(
                new RegExp('%2', 'g'), String(
                    context.exitArg2Lower
                )
            ).replace(
                new RegExp('%3', 'g'), String(
                    context.exitArg3Lower
                )
            ).replace(
                new RegExp('%4', 'g'), String(
                    context.exitArg0
                )
            ).replace(
                new RegExp('%5', 'g'), String(
                    context.exitArg1
                )
            ).replace(
                new RegExp('%6', 'g'), String(
                    context.exitArg2
                )
            ).replace(
                new RegExp('%7', 'g'), String(
                    context.exitArg3
                )
            );

            for (let i = 0; i < this.registeredSubstitutions.length; i++) {
                const pair = this.registeredSubstitutions[i];
                // Only allow a program to be a replacement
                // if it's a perfect match.
                // Also, if it's a perfect match, then there
                // are no other replacements to process.
                if (pair.value && pair.value.isProgram) {
                    const sample = String(str).trim();
                    if (sample === pair.key) {
                        return pair.value;
                    }
                    else if (sample.indexOf(pair.key) > -1) {
                        this.throwTextCompilationNotImplemented();
                    }
                }

                // Otherwise, do other replacements
                str = str.replace(
                    new RegExp(pair.key, 'g'), String(
                        pair.value
                    )
                );
            }
        }
        return convertData(str);
    }

    // For simple execution
    outputEach(programs, context=undefined) {
        if (!context) context = this.createTestContext();
        programs = toArgArray(context, programs);
        for (let i = 0; i < programs.length; i++) {
            this.output(programs[i], context, false);
        }
        context.agent.processMessage(this.getRemainingMessages());
    }

    output(programs, context=undefined, dumpMessagesAfter=true) {
        if (!context) context = this.createTestContext();
        this.outputItem._setField('run', programs);
        this.outputItem.owner = context.agent;
        this.outputItem._executeField(context, 'run');
        if (dumpMessagesAfter) {
            context.agent.processMessage(this.getRemainingMessages());
        }
    }

    dbrefGet(dbref) {
        dbref = forceNumber(dbref);
        for (let i = 0; i < this.registeredObjects.length; i++) {
            const obj = this.registeredObjects[i];
            if (obj.dbref === dbref) return obj;
        }

        throw new Error("No dbref match: " + dbref);
    }

    throwWrongArgCount(programName, foundCount) {
        throw new Error(
            `${programName} has the wrong argument count: ${foundCount}`
        );
    }

    throwTextCompilationNotImplemented() {
        throw new Error("System does not yet support text compilation!");
    }

    // Programs
    a_print(...args) {
        return new Program('@print', (context, args) => {
            args = toArgArray(context, args);
            let res = '';
            for (let i = 0; i < args.length; i++) {
                res += String(reduceData(context, args[i]));
            }
            return context.bridge.registerPrintMessage(res);
        }, args);
    }

    a_switch(...args) {
        return new Program('@switch', (context, args) => {
            args = toArgArray(context, args);
            let fallback = '';
            let limit = args.length;
            if (args.length % 2 === 1 && args.length != 3) {
                throw new Error("@switch has odd number of args");
            }

            if (args.length > 3) {
                fallback = args[args.length - 1];
                limit = args.length - 1;
            }

            const source = String(reduceData(context, args[0]));
            
            for (let i = 1; i < limit; i += 2) {
                let key = String(reduceData(context, args[i]));
                if (source === key) {
                    const res = convertData(context.bridge.a_execute(
                        convertData(args[i + 1])
                    ).execute(context));
                    return res;
                }
            }

            const res = convertData(context.bridge.a_execute(
                fallback
            ).execute(context));
            return res;
        }, args);
    }

    a_strcheck(...args) {
        return new Program('@strcheck', (context, args) => {
            args = toArgArray(context, args);
            for (let i = 0; i < args.length; i++) {
                let item = String(reduceData(context, args[i]));
                if (item.length > 0) return item;
            }

            return "";
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_strCheck(...args) {
        return this.a_strcheck(...args);
    }

    a_execute(...args) {
        return new Program('@execute', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@execute', args.length);
            }

            let line = filterExecutable(context, args[0]);

            if (line.isPrintMessage) {
                line = clearPrintMessage(line);
            }

            while (line.isProgram || (line.isSequence && line.registeredInField)) {
                if (line.isSequence) {
                    line = reduceData(context,
                        (this.a_print(...line.programs)).execute(context)
                    );
                }
                else {
                    line = filterExecutable(context, line.execute(context));
                }
            }
            return line;
        }, args);
    }

    a_call(...args) {
        return new Program('@call', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@call', args.length);
            }

            const caller = context.bridge.dbrefGet(reduceData(context, args[0]));
            const fieldName = reduceData(context, args[1]);

            // There are more rules than this, but this rule is the primary
            // concern for the average MUDder.
            if (caller.owner != context.object.owner) {
                throw new Error("@call causes security error.");
            }

            const newContext = context.bridge.cloneContent(context);
            newContext.agent = caller;
            newContext.object = caller;

            caller._executeField(newContext, fieldName);
        }, args);
    }

    a_fieldloop(...args) {
        return new Program('@fieldloop', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@fieldloop', args.length);
            }

            const fieldParent = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const fieldPrefix = String(reduceData(context, args[1]));
            const iterProgram = args[2];

            const namePair = {
                key: '%f',
                value: ''
            };
            const valuePair = {
                key: '%v',
                value: ''
            };
            context.bridge.registerSubstitution(namePair);
            context.bridge.registerSubstitution(valuePair);

            for (let i = 0; i < fieldParent.fields.length; i++) {
                const myField = fieldParent.fields[i];
                if (!myField.fieldName.startsWith(fieldPrefix)) continue;
                namePair.value = myField.fieldName;
                valuePair.value = myField.value;
                iterProgram.execute(context);
            }

            context.bridge.retireSubstitution(namePair);
            context.bridge.retireSubstitution(valuePair);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_fieldLoop(...args) {
        return this.a_fieldloop(...args);
    }

    a_strloop(...args) {
        return new Program('@strloop', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@strloop', args.length);
            }

            const iterString = String(reduceData(context, args[0]));

            if (iterString.length === 0) return;

            const substKey = String(reduceData(context, args[1]));
            const iterProgram = args[2];

            const charPair = {
                key: '%' + substKey,
                value: ''
            };
            context.bridge.registerSubstitution(charPair);
            
            for (let i = 0; i < iterString.length; i++) {
                const myChar = iterString.charAt(i);
                charPair.value = myChar;
                iterProgram.execute(context);
            }

            context.bridge.retireSubstitution(charPair);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_strLoop(...args) {
        return this.a_strloop(...args);
    }

    a_contentsloop(...args) {
        throw new Error("@contentsloop not implemented!");
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_contentsLoop(...args) {
        return this.a_contentsloop(...args);
    }

    a_for(start, limit, iterProgram) {
        return this.a_countloop(limit, start, iterProgram);
    }

    a_countloop(...args) {
        return new Program('@countloop', (context, args) => {
            args = toArgArray(context, args);
            if (args.length < 3 || args.length > 4) {
                context.bridge.throwWrongArgCount('@countloop', args.length);
            }

            const limit = forceNumber(reduceData(context, args[0]));
            const start = args.length === 3 ? 0 : forceNumber(reduceData(
                context, args[1]
            ));

            if (start >= limit) return;

            const substKey = String(reduceData(
                context, args[args.length === 3 ? 1 : 2]
            ));
            const iterProgram = args[args.length === 3 ? 2 : 3];

            const charPair = {
                key: '%' + substKey,
                value: ''
            };
            context.bridge.registerSubstitution(charPair);
            
            for (let i = start; i < limit; i++) {
                charPair.value = String(i);
                iterProgram.execute(context);
            }

            context.bridge.retireSubstitution(charPair);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_countLoop(...args) {
        return this.a_countloop(...args);
    }

    a_strlen(...args) {
        return new Program('@strlen', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@strlen', args.length);
            }

            return String(reduceData(context, args[0])).length;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_strLen(...args) {
        return this.a_strlen(...args);
    }

    a_substr(...args) {
        return new Program('@substr', (context, args) => {
            args = toArgArray(context, args);
            if (args.length < 2 || args.length > 3) {
                context.bridge.throwWrongArgCount('@substr', args.length);
            }

            const str = String(reduceData(context, args[0]));
            let index = forceNumber(reduceData(context, args[1]));
            let length = args.length === 2 ? undefined : forceNumber(reduceData(
                context, args[2]
            ));

            if (index < 0) {
                index = str.length + index;
            }
            if (length === undefined) {
                length = str.length - index;
            }
            else if (length < 0) {
                length = (str.length - index) + length;
                if (length < 0) length = 0;
            }
            if (length === 0) return "";

            return str.substring(index, index + length);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_subStr(...args) {
        return this.a_substr(...args);
    }

    a_lc(...args) {
        return new Program('@lc', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@lc', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;

            return str.toLowerCase();
        }, args);
    }

    a_uc(...args) {
        return new Program('@uc', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@uc', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;

            return str.toUpperCase();
        }, args);
    }

    a_lcfirst(...args) {
        return new Program('@lcfirst', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@lcfirst', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;
            if (str.length === 1) return str.toLowerCase();

            return str.charAt(0).toLowerCase() +
                str.substring(1, str.length);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_lcFirst(...args) {
        return this.a_lcfirst(...args);
    }

    a_ucfirst(...args) {
        return new Program('@ucfirst', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@ucfirst', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;
            if (str.length === 1) return str.toUpperCase();

            return str.charAt(0).toUpperCase() +
                str.substring(1, str.length);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_ucFirst(...args) {
        return this.a_ucfirst(...args);
    }

    a_substitute(...args) {
        return new Program('@substitute', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@substitute', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;

            return context.bridge.processSubstitutions(context, str);
        }, args);
    }

    a_spformat(...args) {
        return new Program('@spformat', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@spformat', args.length);
            }

            const str = String(reduceData(context, args[0]));

            if (str.length === 0) return str;

            return ' ' + str;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_spFormat(...args) {
        return this.a_spformat(...args);
    }

    a_strcomp(...args) {
        return new Program('@strcomp', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@strcomp', args.length);
            }

            const strA = String(reduceData(context, args[0]));
            const strB = String(reduceData(context, args[1]));

            return strA.localeCompare(strB);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_strComp(...args) {
        return this.a_strcomp(...args);
    }

    a_index(...args) {
        return new Program('@index', (context, args) => {
            args = toArgArray(context, args);
            if (args.length < 2 || args.length > 3) {
                context.bridge.throwWrongArgCount('@index', args.length);
            }

            const str = String(reduceData(context, args[0]));
            const goal = String(reduceData(context, args[1]));
            const start = args.length === 3 ? forceNumber(reduceData(
                context, args[2]
            )) : 0;

            if (goal.length > str.length) return -1;
            if (goal.length === 0) return -1;
            if (str.length === 0) return -1;
            if (start >= str.length) return -1;
            if (start < 0) return -1;

            return str.indexOf(goal, start);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_indexOf(...args) {
        return this.a_index(...args);
    }

    a_replace(...args) {
        return new Program('@replace', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@replace', args.length);
            }

            const str = String(reduceData(context, args[0]));
            const goal = String(reduceData(context, args[1]));
            const replacement = String(reduceData(context, args[2]));

            if (str.length === 0) return str;
            if (goal.length === 0) return str;

            let res = str;
            do {
                res = res.replace(goal, replacement);
            } while (res.indexOf(goal) > -1);
            return res;
        }, args);
    }

    a_transform(...args) {
        throw new Error("@transform not implemented!");
    }

    a_testflag(...args) {
        return new Program('@testflag', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@testflag', args.length);
            }

            const flagParent = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const flagName = String(reduceData(context, args[1]));

            return flagParent._getFlag(flagName) ? 1 : 0;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_testFlag(...args) {
        return this.a_testflag(...args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getFlag(...args) {
        return this.a_testflag(...args);
    }

    a_setflag(...args) {
        return new Program('@setflag', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@setflag', args.length);
            }

            const flagParent = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            let flagName = String(reduceData(context, args[1]));
            let state = true;
            if (flagName.startsWith('!')) {
                flagName = flagName.substring(1);
                state = false;
            }

            flagParent._setFlag(flagName, state);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_setFlag(...args) {
        return this.a_setflag(...args);
    }

    a_getfield(...args) {
        return new Program('@getfield', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@getfield', args.length);
            }

            const fieldParent = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const fieldName = String(reduceData(context, args[1]));

            //console.log(fieldParent._getField(fieldName));

            return fieldParent._getField(fieldName);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getField(...args) {
        return this.a_getfield(...args);
    }

    a_setfield(...args) {
        return new Program('@setfield', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@setfield', args.length);
            }

            const fieldParent = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const fieldName = String(reduceData(context, args[1]));

            fieldParent._setField(fieldName, convertData(args[2]));
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_setField(...args) {
        return this.a_setfield(...args);
    }

    a_g(...args) {
        return new Program('@g', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@g', args.length);
            }

            const varObj = reduceData(
                context,
                context.object._getField('varobj')
            );

            const fieldParent = context.bridge.dbrefGet(varObj);
            const fieldName = String(reduceData(context, args[0]));

            return fieldParent._getField(fieldName);
        }, args);
    }

    a_s(...args) {
        return new Program('@s', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@s', args.length);
            }

            const varObj = reduceData(
                context,
                context.object._getField('varobj')
            );

            const fieldParent = context.bridge.dbrefGet(varObj);
            const fieldName = String(reduceData(context, args[0]));

            fieldParent._setField(fieldName, convertData(args[1]));
        }, args);
    }

    a_location(...args) {
        return new Program('@location', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@location', args.length);
            }

            return context.bridge.dbrefGet(
                reduceData(context, args[0])
            ).dbref;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getLocation(...args) {
        return this.a_location(...args);
    }

    a_toploc(...args) {
        return new Program('@toploc', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@loploc', args.length);
            }

            let loc = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );

            while (!loc.isRoom) {
                loc = loc.location;
            }

            return loc.dbref;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_topLoc(...args) {
        return this.a_topLoc(...args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getRoom(...args) {
        return this.a_toploc(...args);
    }

    a_move(...args) {
        return new Program('@move', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@move', args.length);
            }

            const a = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const b = context.bridge.dbrefGet(
                reduceData(context, args[1])
            );

            // These are not the full rules,
            // but these are the rules that matter to me.
            if (a.owner != context.object.owner) {
                throw new Error("@call causes security error.");
            }

            if (b.owner != context.object.owner) {
                throw new Error("@call causes security error.");
            }

            a.location = b;
        }, args);
    }

    a_setdest(...args) {
        return new Program('@setdest', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@setdest', args.length);
            }

            const a = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );
            const b = context.bridge.dbrefGet(
                reduceData(context, args[1])
            );

            a._setField('link', b.dbref);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_setDest(...args) {
        return this.a_setdest(...args);
    }

    a_player(...args) {
        return new Program('@player', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@player', args.length);
            }

            const name = String(
                reduceData(context, args[0])
            );

            for (let i = 0; i < context.bridge.registeredObjects.length; i++) {
                const item = context.bridge.registeredObjects[i];
                if (!item.isPlayer) continue;
                if (item.matchesName(name)) return item.dbref;
            }

            throw new Error("No player by name: " + name);
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getPlayer(...args) {
        return this.a_player(...args);
    }

    a_object(...args) {
        return new Program('@object', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@object', args.length);
            }

            const name = String(
                reduceData(context, args[1])
            );
            const loc = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );

            for (let i = 0; i < context.bridge.registeredObjects.length; i++) {
                const item = context.bridge.registeredObjects[i];
                if (!item.isObject) continue;
                if (item.location != loc) continue;
                if (item.matchesName(name)) return item.dbref;
            }

            console.log(
                "WARNING: No object in " + loc._getShortName() +
                " by name: " + name
            );

            return -1;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getObject(...args) {
        return this.a_object(...args);
    }

    a_exit(...args) {
        return new Program('@exit', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@exit', args.length);
            }

            const name = String(
                reduceData(context, args[1])
            );
            const loc = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );

            for (let i = 0; i < context.bridge.registeredObjects.length; i++) {
                const item = context.bridge.registeredObjects[i];
                if (!item.isExit) continue;
                if (item.location != loc) continue;
                if (item.matchesName(name)) return item.dbref;
            }

            console.log(
                "WARNING: No exit in " + loc._getShortName() +
                " by name: " + name
            );

            return -1;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getExit(...args) {
        return this.a_exit(...args);
    }

    a_name(...args) {
        return new Program('@name', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@name', args.length);
            }

            // I think this is how it works?
            // Otherwise, how is this any different than shortname?
            return context.bridge.dbrefGet(
                reduceData(context, args[0])
            ).vocab;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getName(...args) {
        return this.a_name(...args);
    }

    a_shortname(...args) {
        return new Program('@shortname', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@shortname', args.length);
            }

            return context.bridge.dbrefGet(
                reduceData(context, args[0])
            )._getShortName();
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getShortName(...args) {
        return this.a_shortname(...args);
    }

    a_type(...args) {
        return new Program('@type', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@type', args.length);
            }

            return context.bridge.dbrefGet(
                reduceData(context, args[0])
            ).objectType;
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_getType(...args) {
        return this.a_type(...args);
    }

    a_eq(...args) {
        return new Program('@eq', (context, args) => {
            args = toArgArray(context, args);
            if (args.length < 2) {
                context.bridge.throwWrongArgCount('@eq', args.length);
            }

            const first = String(reduceData(args[0]));

            for (let i = 1; i < args.length; i++) {
                const comp = String(reduceData(args[i]));
                if (first != comp) return 0;
            }

            return 1;
        }, args);
    }

    a_lt(...args) {
        return new Program('@lt', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@lt', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return first < second ? 1 : 0;
        }, args);
    }

    a_gt(...args) {
        return new Program('@gt', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@gt', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return first > second ? 1 : 0;
        }, args);
    }

    a_and(...args) {
        return new Program('@and', (context, args) => {
            args = toArgArray(context, args);
            if (args.length === 0) {
                context.bridge.throwWrongArgCount('@and', args.length);
            }

            for (let i = 0; i < args.length; i++) {
                const comp = forceBool(reduceData(args[i]));
                if (comp === 0) return 0;
            }

            return 1;
        }, args);
    }

    a_or(...args) {
        return new Program('@or', (context, args) => {
            args = toArgArray(context, args);
            if (args.length === 0) {
                context.bridge.throwWrongArgCount('@or', args.length);
            }

            for (let i = 0; i < args.length; i++) {
                const comp = forceBool(reduceData(args[i]));
                if (comp === 1) return 1;
            }

            return 0;
        }, args);
    }

    a_not(...args) {
        return new Program('@not', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@not', args.length);
            }

            return forceBool(reduceData(args[0])) === 0 ? 1 : 0;
        }, args);
    }

    a_xor(...args) {
        return new Program('@xor', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@xor', args.length);
            }

            const first = forceBool(reduceData(args[0]));
            const second = forceBool(reduceData(args[1]));

            return first != second;
        }, args);
    }

    a_add(...args) {
        return new Program('@add', (context, args) => {
            args = toArgArray(context, args);
            if (args.length === 0) {
                context.bridge.throwWrongArgCount('@and', args.length);
            }

            let res = 0;

            for (let i = 0; i < args.length; i++) {
                res += forceNumber(reduceData(args[i]));
            }

            return res;
        }, args);
    }

    a_sub(...args) {
        return new Program('@sub', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@sub', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return first - second;
        }, args);
    }

    a_mul(...args) {
        return new Program('@mul', (context, args) => {
            args = toArgArray(context, args);
            if (args.length === 0) {
                context.bridge.throwWrongArgCount('@mul', args.length);
            }

            let res = 1;

            for (let i = 0; i < args.length; i++) {
                res *= forceNumber(reduceData(args[i]));
            }

            return res;
        }, args);
    }

    a_div(...args) {
        return new Program('@div', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@div', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return first / second;
        }, args);
    }

    a_idiv(...args) {
        return new Program('@idiv', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@idiv', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return Math.floor(first / second);
        }, args);
    }

    a_mod(...args) {
        return new Program('@mod', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@mod', args.length);
            }

            const first = forceNumber(reduceData(args[0]));
            const second = forceNumber(reduceData(args[1]));

            return first % second;
        }, args);
    }

    a_neg(...args) {
        return new Program('@neg', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@neg', args.length);
            }

            const first = forceNumber(reduceData(args[0]));

            return first * -1;
        }, args);
    }

    a_log(...args) {
        throw new Error("@log not implemented!");
    }

    a_ln(...args) {
        throw new Error("@ln not implemented!");
    }

    a_exp(...args) {
        throw new Error("@exp not implemented!");
    }

    a_rand(...args) {
        return new Program('@rand', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 1) {
                context.bridge.throwWrongArgCount('@rand', args.length);
            }

            const max = forceNumber(reduceData(args[0]));

            let res = Math.floor(Math.random() * max);
            if (res === max) res = max - 1;
            if (res < 0) res = 0;

            return res;
        }, args);
    }

    a_sin(...args) {
        throw new Error("@sin not implemented!");
    }

    a_cos(...args) {
        throw new Error("@cos not implemented!");
    }

    a_event(...args) {
        //TODO: Implement approximations of events
        throw new Error("@event not implemented!");
    }

    a_killevent(...args) {
        //TODO: Implement approximations of events
        throw new Error("@killevent not implemented!");
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_killEvent(...args) {
        return this.a_killevent(...args);
    }

    a_statevent(...args) {
        //TODO: Implement approximations of events
        throw new Error("@statevent not implemented!");
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_statEvent(...args) {
        return this.a_statevent(...args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_stateEvent(...args) {
        return this.a_statevent(...args);
    }

    a_tell(...args) {
        return new Program('@tell', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 2) {
                context.bridge.throwWrongArgCount('@tell', args.length);
            }

            const receiver = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );

            if (!receiver.isPlayer) {
                throw new Error(receiver._getShortName() + " is not a valid player.");
            }

            receiver.processMessage(String(reduceData(context, args[1])));
        }, args);
    }

    a_tellroom(...args) {
        return new Program('@tellroom', (context, args) => {
            args = toArgArray(context, args);
            if (args.length != 3) {
                context.bridge.throwWrongArgCount('@tellroom', args.length);
            }

            const receiver = context.bridge.dbrefGet(
                reduceData(context, args[0])
            );

            if (!receiver.isRoom) {
                throw new Error(receiver._getShortName() + " is not a valid room.");
            }

            const forbidden = [];
            const forbiddenCandidates = unpackSequence(context, args[1]);
            for (let i = 0; i < forbiddenCandidates.length; i++) {
                const item = context.bridge.dbrefGet(
                    reduceData(context, forbiddenCandidates[i])
                );
                if (!item.isPlayer) continue;
                forbidden.push(item);
            }

            const msg = String(reduceData(context, args[2]));

            for (let i = 0; i < context.bridge.registeredObjects.length; i++) {
                const item = context.bridge.registeredObjects[i];
                if (!item.isPlayer) continue;
                if (item.location != receiver) continue;
                if (forbidden.indexOf(item) > -1) continue;
                item.processMessage(msg);
            }
        }, args);
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_tellRoom(...args) {
        return this.a_tellroom(...args);
    }

    a_tellchannel(...args) {
        throw new Error("@tellchannel not implemented!");
    }

    /**
     * Misspell backup
     * @deprecated This is misspelled, but will still compile.
     * @private
     */
    a_tellChannel(...args) {
        return this.a_tellchannel(...args);
    }

    a_time(...args) {
        throw new Error("@time not implemented!");
    }

    a_let(...args) {
        return new Program('@let', (context, args) => {
            args = toArgArray(context, args);
            if (args.length < 3 || args.length % 2 === 0) {
                context.bridge.throwWrongArgCount('@let', args.length);
            }

            const subProgram = args[args.length - 1];
            const pairs = [];
            for (let i = 0; i < args.length - 1; i += 2) {
                const pair = {
                    key: '%' + args[i],
                    value: args[i+1]
                };
                pairs.push(pair);
                context.bridge.registerSubstitution(pair);
            }

            const res = subProgram.execute(context);

            for (let i = 0; i < pairs.length; i++) {
                context.bridge.retireSubstitution(pairs[i]);
            }

            return res;
        }, args);
    }

    a_null(...args) {
        return new Program('@null', (context, args) => {
            args = toArgArray(context, args);
            if (args.length > 0) {
                context.bridge.throwWrongArgCount('@null', args.length);
            }

            return "";
        }, args);
    }
}

module.exports = {
    createBridge() {
        return new JotaBridge();
    }
};